# Docker Compose Node.js and MongoDB Lab

## Lab Objective

This lab provides a step-by-step guide for deploying a multi-container application using Docker Compose. The application comprises a Node.js web service and a MongoDB database, with built-in mechanisms for persistent storage of both application logs and database data.

**Estimated Completion Time:** 20 minutes

## Prerequisites

Before you begin this lab, please ensure your development environment is set up with the following tools:

* **Docker Engine (Version 24.x or later):** This includes the Docker CLI.
* **Docker Compose (Version 2 or later):**
* **A Code Editor:** Such as Visual Studio Code, Notepad++, or cursor.

## Lab Steps

Follow these instructions carefully. Each step is designed to build upon the previous one, leading to a fully functional multi-container application.

---

### Step 1: Project Setup and File Creation

This step focuses on organizing the project directory and populating it with the necessary application code and Docker configurations.

1.  **Create the main project directory:**
    Open your terminal (Command Prompt, PowerShell, or Bash) and execute the following commands to create the root directory for our project:
    ```bash
    mkdir multi-container-lab
    cd multi-container-lab
    ```

2.  **Create the `app` subdirectory:**
    This directory will house our Node.js application files.
    ```bash
    mkdir app
    ```

3.  **Populate `app/package.json`:**
    Navigate into the `app` directory (`cd app`). Open `package.json` in your preferred code editor and **[TEAM MEMBER A: Paste your final `package.json` content here]**:

    ```json
    # [PASTE YOUR FINAL PACKAGE.JSON CONTENT HERE]
    ```
    *(Save the file and close your editor.)*

4.  **Populate `app/index.js`:**
    While still in the `app` directory, open `index.js` in your code editor and **[TEAM MEMBER B: Paste your final `index.js` content here]**:

    ```javascript
    # [PASTE YOUR FINAL INDEX.JS CONTENT HERE]
    ```
    *(Save the file and close your editor.)*

5.  **Populate `Dockerfile` (for the Node.js app):**
    Navigate back to the main `multi-container-lab` directory (`cd ..`). Open `Dockerfile` in your code editor and **[TEAM MEMBER C: Paste your final `Dockerfile` content here]**:

    ```dockerfile
    # [PASTE YOUR FINAL DOCKERFILE CONTENT HERE]
    ```
    *(Save the file and close your editor.)*

6.  **Populate `docker-compose.yml`:**
    Ensure you are in the main `multi-container-lab` directory. Open `docker-compose.yml` in your code editor and **[YOUR PART: Paste your final `docker-compose.yml` content here]**:

    ```yaml
    # [PASTE YOUR FINAL DOCKER-COMPOSE.YML CONTENT HERE]
    ```
    *(Save the file and close your editor.)*

---

### Step 2: Build and Deploy the Application

In this step, you will use Docker Compose to build the Node.js application image and deploy both services (`app` and `mongo`).

1.  **Navigate to the project root:**
    Make sure your terminal's current working directory is `multi-container-lab`, where your `docker-compose.yml` file resides.
    ```bash
    cd C:\path\to\your\multi-container-lab
    ```
    *(**Important:** Replace `C:\path\to\your` with the actual path to your `multi-container-lab` folder on your system. And delete this line afterwards ew3y tensy)* 

2.  **Build and start services:**
    Execute the following command to build your Node.js application image and start all defined services in detached mode (background). This may take a few minutes as Docker pulls base images and installs Node.js dependencies.
    ```bash
    docker compose up --build -d
    ```
    *Allow sufficient time for images to download and services to fully initialize.*

---

### Step 3: Verify Application Functionality

Once the services are running, confirm that the application is operating as expected.

1.  **Check running services:**
    List all running Docker Compose services to ensure both `app` and `mongo` containers are active:
    ```bash
    docker compose ps
    ```
    *Expected Output: Both `app` and `mongo` services should show an `Up` status.*

2.  **Access the web application:**
    Open your web browser and navigate to the application's URL:
    [http://localhost:3000](http://localhost:3000)
    *Expected Output: You should see the "Hello from Docker + MongoDB!" message, along with the MongoDB connection status.*

3.  **View application logs:**
    Inspect the logs generated by the `app` service to confirm connection status and startup messages:
    ```bash
    docker compose logs app
    ```
    *Expected Output: Log entries indicating app startup and MongoDB connection status.*

4.  **Verify persistent volumes:**
    Confirm that the named Docker volumes, `logs` and `mongo-data`, have been created successfully for persistence:
    ```bash
    docker volume ls
    ```
    *Expected Output: Volumes named similar to `multi-container-lab_logs` and `multi-container-lab_mongo-data` should be listed.*

---

### Step 4: Demonstrate Data Persistence (Optional, but Recommended for Full Lab Completion)

This step showcases how data written to volumes persists even if containers are stopped or recreated.

1.  **Tear down services and remove volumes:**
    To simulate a full cleanup and re-deployment, stop and remove all services, including their associated named volumes.
    ```bash
    docker compose down -v
    ```
    ***Caution: This command will permanently delete any data stored in your `mongo-data` volume.***

2.  **Re-run the application:**
    Start the application again from scratch. The volumes will be recreated, and any data previously stored in `mongo-data` (if not deleted by `--down -v`) would persist.
    ```bash
    docker compose up --build -d
    ```

3.  **Re-access the web application:**
    Open your browser to [http://localhost:3000](http://localhost:3000) once more.
    *Expected Output: The application should respond, and if MongoDB had any persistent data written by a previous run (which our current simple app doesn't directly do beyond connecting), that data would still be available, demonstrating volume persistence.*

---

## Conclusion

Congratulations! You have successfully deployed a multi-container Node.js and MongoDB application using Docker Compose, gaining practical experience in service orchestration and persistent data management with Docker volumes.
